#!/bin/sh

# Copyright (c) 2015-2018 Oliver Mahmoudi
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions 
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# mapdir - A utility to map files and directory hierarchies

# Functions:
# readfile()
# get_filename()
# check_savefile_existence()
# usage()

# Variables:
READLINK=
CHECKSUM=
DATE=$(date +%m%d%Y)		# today
OS_TYPE=$(uname)
DEPTH=0
FDE=						# number of first dir entries
SAVEFILE=
STRLEN=						# for nice output at the end
# variables that are used for the statistics at the end of the program
DIRS=0
UNREADABLE_DIRS=0
FILES=0
UNREADABLE_FILES=0
BLOCK_SPECIALS=0
CHARACTER_SPECIALS=0
PIPES=0
SOCKETS=0
SYMBOLIC_LINKS=0
UNKNOWN=0
SAVEIFS=$IFS			# save the current Internal Field Seperator
IFS=$(echo -en "\n\b")		# and set a new one
export LC_COLLATE=C
# flags for getopts
d_flag=0				# dotglob flag
f_flag=0				# f flag for getopts
h_flag=0				# use sha256sum flag
n_flag=0				# no savefile flag
p_flag=0				# display output as directory tree
s_flag=0
s_file=					# alternate savefile

readfile() 
{
	local _dir _contents _entry _file _newpath

	_file=$1

	if [ -d $_file ]; then
		if [ -r $_file ] && [ -x $_file ]; then
			if [ $f_flag -eq 0 ]; then
				echo $_file - directory
				if [ $n_flag -eq 0 ]; then
					echo $_file - directory >> $SAVEFILE
				fi
			else
				if [ $2 -eq 0 ]; then
					echo $(get_filename $_file) - directory
					if [ $n_flag -eq 0 ]; then
						echo $(get_filename $_file) - directory >> $SAVEFILE
					fi
				fi
			fi
			DIRS=$((DIRS+1))				# gather statistics
			_dir=$_file
			cd $_dir
			_contents=*
			if [[ ! -z $_contents ]] ; then	# directory has contents
				# if this is the first time around we encounter a directory,
				# get the # of entries
				if [ $DEPTH -eq 0 ] ; then
					FDE=($_contents)
				fi				
##				DEPTH=$(($DEPTH+1))
				for _entry in $_contents ; do
					_newpath=$_dir/"$_entry"
					readfile $_newpath 0 $DEPTH
				done
			fi
		else 
			if [ $f_flag -eq 0 ]; then
				echo $_file - directory is not readable
				if [ $n_flag -eq 0 ]; then
					echo $_file - directory is not readable >> $SAVEFILE
				fi
			else
				if [ $2 -eq 0 ]; then
					echo $(get_filename $_file) - directory is not readable
					if [ $n_flag -eq 0 ]; then
						echo $(get_filename $_file) - directory is not readable >> $SAVEFILE
					fi
				fi
			fi
			UNREADABLE_DIRS=$((UNREADABLE_DIRS+1))		# gather statistics
		fi
	elif [ -b $_file ]; then
		if [ $f_flag -eq 0 ]; then
			echo $_file - block special file
			if [ $n_flag -eq 0 ]; then
				echo $_file - block special file >> $SAVEFILE
			fi
		else
			echo $(get_filename $_file) - block special file
			if [ $n_flag -eq 0 ]; then
				echo $(get_filename $_file) - block special file >> $SAVEFILE
			fi
		fi
		BLOCK_SPECIALS=$((BLOCK_SPECIALS+1))			# gather statistics
	elif [ -c $_file ]; then
		if [ $f_flag -eq 0 ]; then
			echo $_file - character special file
			if [ $n_flag -eq 0 ]; then
				echo $_file - character special file >> $SAVEFILE
			fi
		else
			echo $(get_filename $_file) - character special file
			if [ $n_flag -eq 0 ]; then
				echo $(get_filename $_file) - character special file >> $SAVEFILE
			fi
		fi
		CHARACTER_SPECIALS=$((CHARACTER_SPECIALS+1))		# gather statistics
	elif [ -L $_file ]; then
		if [ $f_flag -eq 0 ]; then
			echo $_file - symbolic link
			if [ $n_flag -eq 0 ]; then
				echo $_file - symbolic link >> $SAVEFILE
			fi
		else
			echo $(get_filename $_file) - symbolic link
			if [ $n_flag -eq 0 ]; then
				echo $(get_filename $_file) - symbolic link >> $SAVEFILE
			fi
		fi
		SYMBOLIC_LINKS=$((SYMBOLIC_LINKS+1))			# gather statistics
	elif [ -f $_file ]; then
		if [ -r $_file ]; then				# it's a readable file
			if [ $f_flag -eq 0 ]; then		# log the entire path to the file
				get_file_stats $_file readable
#				pretty_output $DEPTH $_file 0
			else							# just log the filename via get_filename()
				get_file_stats $(get_filename $_file) readable
#				pretty_output $DEPTH $_file 0



#if [ "$OS_TYPE" = "Linux" ] ; then
#echo $(get_filename $_file) - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
#${CHECKSUM}: `${CHECKSUM} $_file | awk '{ print $1 }'`
#if [ $n_flag -eq 0 ]; then
#echo $(get_filename $_file) - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
#${CHECKSUM}: `${CHECKSUM} $_file | awk '{ print $1 }'` >> $SAVEFILE
#fi
#elif [ "$OS_TYPE" = "FreeBSD" ] ; then
#echo $(get_filename $_file) - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
#${CHECKSUM}: `${CHECKSUM} $_file | awk '{ print $4 }'`
#if [ $n_flag -eq 0 ]; then
#echo $(get_filename $_file) - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
#${CHECKSUM}: `${CHECKSUM} $_file | awk '{ print $4 }'` >> $SAVEFILE
#fi
#fi
			fi
			FILES=$((FILES+1))				# gather statistics
		else 								# unreadable file
			if [ $f_flag -eq 0 ]; then		# log entire path to file
				get_file_stats $_file unreadable
			else							# only log the filename via get_filename()
				get_file_stats $(get_filename $_file) unreadable
#echo $(get_filename $_file) - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
#${CHECKSUM}: not readable
#if [ $n_flag -eq 0 ]; then
#echo $(get_filename $_file) - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
#${CHECKSUM}: not readable >> $SAVEFILE
#fi
			fi
			UNREADABLE_FILES=$((UNREADABLE_FILES+1))	# gather statistics
		fi									# unreadable file
	elif [ -p $_file ]; then
		if [ $f_flag -eq 0 ]; then
			echo $_file - pipe
			if [ $n_flag -eq 0 ]; then
				echo $_file - pipe >> $SAVEFILE
			fi
		else
			echo $(get_filename $_file) - pipe
			if [ $n_flag -eq 0 ]; then
				echo $(get_filename $_file) - pipe >> $SAVEFILE
			fi
		fi
		PIPES=$((PIPES+1))					# gather statistics
	elif [ -S $_file ]; then
		if [ $f_flag -eq 0 ]; then
			echo $_file - socket
			if [ $n_flag -eq 0 ]; then
				echo $_file - socket >> $SAVEFILE
			fi
		else
			echo $(get_filename $_file) - socket
			if [ $n_flag -eq 1 ]; then
				echo $(get_filename $_file) - socket >> $SAVEFILE
			fi
		fi
		SOCKETS=$((SOCKETS+1))					# gather statistics
	else
		if [ $f_flag -eq 0 ]; then
			echo $_file - unknown file type
			if [ $n_flag -eq 0 ]; then
				echo $_file - unknown file type >> $SAVEFILE
			fi
		else
			echo $(get_filename $_file) - unknown file type
			if [ $n_flag -eq 0 ]; then
				echo $(get_filename $_file) - unknown file type >> $SAVEFILE
			fi
		fi
		UNKNOWN=$((UNKNOWN+1))
	fi
}

get_file_stats()
{
	local _file

	_file=$1

	if [ "$2" = "readable" ] ; then
		if [ "$OS_TYPE" = "Linux" ] ; then
			echo $_file - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
			${CHECKSUM}: `${CHECKSUM} $_file | awk '{ print $1 }'`
				if [ $n_flag -eq 0 ]; then
					echo $_file - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
					${CHECKSUM}: `${CHECKSUM} $_file | awk '{ print $1 }'` >> $SAVEFILE
				fi
		elif [ "$OS_TYPE" = "FreeBSD" ] ; then
			echo $_file - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
			${CHECKSUM}: `${CHECKSUM} $_file | awk '{ print $4 }'`
				if [ $n_flag -eq 0 ]; then
					echo $_file - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
					${CHECKSUM}: `${CHECKSUM} $_file | awk '{ print $4 }'` >> $SAVEFILE
				fi
		fi
	elif ["$2" = "unreadable" ] ; then
		echo $_file - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
		${CHECKSUM}: not readable
		if [ $n_flag -eq 0 ]; then
			echo $_file - regular file - Size: `ls -l $_file | awk '{ print $5 }'` bytes - \
			${CHECKSUM}: not readable >> $SAVEFILE
		fi
	fi
}

pretty_output()
{
# space=""  <==> space="${space}"	# level 0 seqs: 1, 1, 0 =>  0 spaces, end:  0
# space=" " <==> space="${space} "	# level 1 seqs: 1, 1, 1 =>  1 space,  end:  2
# space=" " <==> space="${space} "	# level 2 seqs: 1, 1, 2 =>  3 spaces, end:  4
# space=" " <==> space="${space} "	# level 3 seqs: 1, 1, 3 =>  5 spaces, end:  6
# space=" " <==> space="${space} "	# level 4 seqs: 1, 1, 4 =>  7 spaces, end:  8
# space=" " <==> space="${space} "	# level 5 seqs: 1, 1, 5 =>  9 spaces, end: 10
# space=" " <==> space="${space} "	# level 6 seqs: 1, 1, 6 => 11 spaces, end: 12
#...
	local _level _entry _lastentry
	declare -r seq_start_val=1
	declare -r seq_step_val=1
	seq_end_val=$1
	_level=$1
	_entry=$2
	_lastentry=$3

	space=" "				
	if [ $_level -eq 0 ] ; then
		echo "|-$_entry"
	elif [ $_level -eq 1 ] ; then
		if [ $_lastentry -eq 1 ] ; then
			echo " ${space}|-$_entry"
		else
			echo "|${space}|-$_entry"
		fi
	elif [ $_level -gt 1 ] ; then
		for i in $(seq $seq_start_val $seq_step_val $seq_end_val)
		do
			space="${space} "
		done
		if [ $_lastentry -eq 1 ] ; then
			echo " ${space}|-$_entry"
		else
			echo "|${space}|-$_entry"
		fi
	fi
}

get_filename()
{
	local _filename

	# use awk to get the last "/" character and get the right part of it	
	_filename=$(awk -v filename=$1 'BEGIN {
		n = split(filename, a, "/");
		print a[n];
	}')
	
	echo $_filename
}

check_savefile_existence()
{
	local choice

	if [ -e $1 ] ; then
		# Confirm
		echo -n "The savefile: $1 already exists. Do you want to overwrite it Yes/No? "
		read -t 30 choice		# We got 30 seconds to make a choice

		case $choice in

		[Yy][Ee][Ss] | [Yy] )
			rm -v $1
			;;
		[Nn][Oo] | [Nn] )
			echo 'Aborted!'
			exit 1
			;;
		*)
			echo "No input received. Terminating."
			exit 1
			;;
		esac
	fi
}

usage()
{
	echo usage: mapdir [-dfhnp] [-s savefile] [file]||[directory]
	exit 1
}

### Point of entry ###

while getopts ":dfhnps:" opt ; do
	case $opt in
		d)
			d_flag=1
			;;
		f)
			f_flag=1
			;;
		h)
			h_flag=1
			;;
		n)
			n_flag=1
			;;
		p)
			p_flag=1
			;;
		s)
			s_flag=1
			s_file=$OPTARG
			;;
		\?)
			echo "unkown flag: -$OPTARG."
			usage
			exit
			;;
	esac
done

shift $((OPTIND-1))

# sanity checks
if [ $p_flag -eq 1 ] && [ $f_flag -eq 0 ] ; then
	echo "The -p option can only be used with the -f option."
	exit
fi

if [ $d_flag -eq 0 ]; then
	shopt -s dotglob nullglob
else
	shopt -s nullglob
fi

if [ "${OS_TYPE}" = "Linux" ] ; then
	if [ $h_flag -eq 1 ]; then				# Change CHECKSUM to sha256sum
		CHECKSUM=sha256sum
	else
		CHECKSUM=md5sum
	fi
elif [ "${OS_TYPE}" = "FreeBSD" ] ; then
	if [ $h_flag -eq 1 ]; then				# Change CHECKSUM to sha256
		CHECKSUM=sha256
	else
		CHECKSUM=md5
	fi
fi

#
# If an argument is given, take it, otherwise process the current directory.
#

if [ $# -eq 1 ]; then
	if [ ! -e $(readlink -f $1) ]; then
 		echo The file `readlink -f $1` doesn\'t exist.
		usage
	fi
	READLINK=$(readlink -f $1)
	if [ $n_flag -eq 0 ]; then
		if [ $s_flag -eq 0 ]; then
			SAVEFILE=~/mapdir$(readlink -f $1 | sed s#/#_#g)_$DATE.txt
			check_savefile_existence $SAVEFILE
			: > $SAVEFILE
		else
			SAVEFILE=~/${s_file}
			check_savefile_existence $SAVEFILE
			: > $SAVEFILE
		fi
	fi
else
	READLINK=$(readlink -f ./)
	if [ $n_flag -eq 0 ]; then
		if [ $s_flag -eq 0 ]; then
			SAVEFILE=~/mapdir$(pwd | sed s#/#_#g)_$DATE.txt
			check_savefile_existence $SAVEFILE
			:> $SAVEFILE
		else
			SAVEFILE=~/${s_file}
			check_savefile_existence $SAVEFILE
			: > $SAVEFILE
		fi
	fi
fi

echo Mapping structure of: $READLINK
if [ $n_flag -eq 0 ]; then
	if [ $f_flag -eq 0 ]; then
		echo Mapping structure of: $READLINK >> $SAVEFILE
	fi
fi

# When calling the readline function for the first time, we pass a second argument of "1" to it.
# This serves the purpose of pleasing the diff utility when invoking mapdir with the -f switch
# and having a directory as the first argument. If we would map the starting directory to the
# $SAVEFILE and would later on compare it with another the $SAVEFILE, the diff utility would
# obviously exit with a return value other than 0, even though the contents of the directories
# may be truly equivalent. Consider for example the folders:
# /media/filesystem_a and /media/filesystem_b that both have the same content.
#
# The logic is as follows: if the file is a folder, then the readlink function detects this in
# the "is directory" part and skips mapping its occurence to the $SAVEFILE. For subsequent calls
# to readlink we will pass a second argument of "0" to the function, which this time maps it.
#
# Start processing the file/folder...

readfile $READLINK 1 $DEPTH

#
# At this point, we are done parsing.
#

echo
if [ $n_flag -eq 0 ]; then
	echo >> $SAVEFILE
fi

STRLEN="########## Statistics for $READLINK ##########"
echo $STRLEN
if [ $n_flag -eq 0 ]; then
	if [ $f_flag -eq 0 ]; then
		echo $STRLEN >> $SAVEFILE
	else
		echo "########## Statistics ##########" >> $SAVEFILE
	fi
fi

if [ $DIRS -ne 0 ]; then 
	echo Number of directories: $DIRS
	if [ $n_flag -eq 0 ]; then
		echo Number of directories: $DIRS >> $SAVEFILE
	fi
fi
if [ $UNREADABLE_DIRS -ne 0 ]; then 
	echo Number of unreadable directories: $UNREADABLE_DIRS
	if [ $n_flag -eq 0 ]; then
		echo Number of unreadable directories: $UNREADABLE_DIRS >> $SAVEFILE
	fi
fi
if [ $FILES -ne 0 ]; then
	echo Number of regular files: $FILES
	if [ $n_flag -eq 0 ]; then
		echo Number of regular files: $FILES >> $SAVEFILE
	fi
fi
if [ $UNREADABLE_FILES -ne 0 ]; then
	echo Number of unreadble files: $UNREADABLE_FILES
	if [ $n_flag -eq 0 ]; then
		echo Number of unreadble files: $UNREADABLE_FILES >> $SAVEFILE
	fi
fi
if [ $BLOCK_SPECIALS -ne 0 ]; then
	echo Number of block special files: $BLOCK_SPECIALS
	if [ $n_flag -eq 0 ]; then
		echo Number of block special files: $BLOCK_SPECIALS >> $SAVEFILE
	fi
fi
if [ $CHARACTER_SPECIALS -ne 0 ]; then
	echo Number of character speial files: $CHARACTER_SPECIAL
	if [ $n_flag -eq 0 ]; then
		echo Number of character speial files: $CHARACTER_SPECIAL >> $SAVEFILE
	fi
fi
if [ $PIPES -ne 0 ]; then
	echo Number of pipes: $PIPE
	if [ $n_flag -eq 0 ]; then
		echo Number of pipes: $PIPE >> $SAVEFILE
	fi
fi
if [ $SOCKETS -ne 0 ]; then 
	echo Number of sockets: $SOCKET
	if [ $n_flag -eq 0 ]; then
		echo Number of sockets: $SOCKET >> $SAVEFILE
	fi
fi
if [ $SYMBOLIC_LINKS -ne 0 ]; then
	echo Number of symbolic links: $SYMBOLIC_LINKS
	if [ $n_flag -eq 0 ]; then
		echo Number of symbolic links: $SYMBOLIC_LINKS >> $SAVEFILE
	fi
fi
if [ $UNKNOWN -ne 0 ]; then
	echo Number of symbolic links: $UNKNOWN
	if [ $n_flag -eq 0 ]; then
		echo Number of symbolic links: $UNKNOWN >> $SAVEFILE
	fi
fi

#
# pretty output
#
STRLEN=${#STRLEN}
while [ $STRLEN -gt 0 ]
do
	echo -n "#"
	if [ $n_flag -eq 0 ]; then
		if [ $f_flag -eq 0 ]; then
			echo -n "#" >> $SAVEFILE
		fi
	fi
	STRLEN=$((STRLEN-1))
done
IFS=$SAVEIFS			# reset the old IFS
echo
if [ $n_flag -eq 0 ]; then
	if [ $f_flag -eq 0 ]; then
		echo >> $SAVEFILE
	else
		echo "################################" >> $SAVEFILE
	fi
fi
echo Done!
if [ $n_flag -eq 0 ]; then
	echo Done! >> $SAVEFILE
fi
exit 0
